== Querschnittliche Konzepte

Dieses Kapitel beschreibt übergreifende Konzepte, die in mehreren Bausteinen zum Einsatz kommen.

// 8.1 Domänenmodell und Fachliche Architektur
=== 8.1 Domänenmodell und Fachliche Architektur

==== 8.1.1 Ubiquitous Language

Das System verwendet konsequent die Fachbegriffe der Domäne:

* *Verein*, *Team*, *Kind* (nicht: Club, Group, Child)
* *Wettkampf*, *Durchgang*, *Start* (nicht: Competition, Round, Attempt)
* *Kampfrichter*, *Punktrichter*, *Offizieller* (nicht: Judge, Referee, Official)
* *Figur*, *Schwierigkeitsfaktor* (nicht: Figure, Difficulty)

Diese Begriffe werden durchgängig verwendet: in der Datenbank, API, UI und Dokumentation.

==== 8.1.2 Fachliche Module (Bounded Contexts)

----
┌─────────────────────────────────────────────────────────┐
│                     Aquarius System                      │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌────────────────┐    ┌────────────────┐              │
│  │  Stammdaten    │    │ Saisonplanung  │              │
│  │                │    │                │              │
│  │ • Verein       │    │ • Saison       │              │
│  │ • Team         │    │ • Figuren      │              │
│  │ • Kind         │    │ • Wettkämpfe   │              │
│  │ • Offizieller  │    │ • Schwimmbäder │              │
│  └────────────────┘    └────────────────┘              │
│                                                          │
│  ┌────────────────┐    ┌────────────────┐              │
│  │  Anmeldung     │    │  Wettkampf     │              │
│  │                │    │                │              │
│  │ • Registrierung│    │ • Stationen    │              │
│  │ • Startnummern │    │ • Gruppen      │              │
│  │ • Validierung  │    │ • Durchgänge   │              │
│  └────────────────┘    └────────────────┘              │
│                                                          │
│  ┌────────────────┐    ┌────────────────┐              │
│  │  Bewertung     │    │  Auswertung    │              │
│  │                │    │                │              │
│  │ • Punkteingabe │    │ • Ranglisten   │              │
│  │ • Berechnung   │    │ • Preisvergabe │              │
│  │ • Validierung  │    │ • Export       │              │
│  └────────────────┘    └────────────────┘              │
└─────────────────────────────────────────────────────────┘
----

*Abhängigkeiten zwischen Modulen:*

* Anmeldung → Stammdaten, Saisonplanung
* Wettkampf → Anmeldung, Stammdaten
* Bewertung → Wettkampf
* Auswertung → Bewertung, Wettkampf

[IMPORTANT]
====
*Regel:* Module dürfen nur über definierte Schnittstellen kommunizieren, keine direkten Datenbankzugriffe über Modulgrenzen.
====

==== 8.1.3 Wiederkehrender Aufbau fachlicher Module

Jedes fachliche Modul folgt einer *einheitlichen 3-Schichten-Architektur*:

----
┌──────────────────────────────────────┐
│         Router (API Layer)           │  ← REST-Endpunkte, HTTP-Handling
│  - Request-Validierung (Pydantic)    │
│  - Response-Serialisierung           │
│  - HTTP-Status-Codes                 │
└─────────────┬────────────────────────┘
              │
              │ DTOs (Data Transfer Objects)
              ▼
┌──────────────────────────────────────┐
│        Service (Business Layer)      │  ← Geschäftslogik, Orchestrierung
│  - Business-Rules                    │
│  - Workflow-Koordination             │
│  - Inter-Modul-Kommunikation         │
│  - Transaktionssteuerung             │
└─────────────┬────────────────────────┘
              │
              │ Domain-Objekte
              ▼
┌──────────────────────────────────────┐
│      Repository (Data Layer)         │  ← Datenbankzugriff
│  - CRUD-Operationen                  │
│  - Queries                           │
│  - ORM-Mapping                       │
└──────────────────────────────────────┘
----

===== Verantwortlichkeiten pro Schicht

*1. Router (API Layer)*

[source,python]
----
# backend/app/routers/anmeldung.py
from fastapi import APIRouter, Depends, HTTPException, status
from app.schemas.anmeldung import AnmeldungCreate, AnmeldungResponse
from app.services.anmeldung_service import AnmeldungService

router = APIRouter(prefix="/api/anmeldungen", tags=["anmeldungen"])

@router.post("/", response_model=AnmeldungResponse, status_code=status.HTTP_201_CREATED)
async def create_anmeldung(
    data: AnmeldungCreate,
    service: AnmeldungService = Depends()
):
    """Neue Anmeldung erstellen"""
    try:
        result = service.create_anmeldung(data)
        return result
    except DoppelmeldungError as e:
        raise HTTPException(status_code=409, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
----

*Aufgaben:*

* HTTP-Request entgegennehmen
* DTO-Validierung (automatisch durch Pydantic)
* Service-Methoden aufrufen
* Exceptions in HTTP-Status-Codes übersetzen
* Response serialisieren

[WARNING]
====
*Keine Business-Logik im Router!*
====

*2. Service (Business Layer)*

[source,python]
----
# backend/app/services/anmeldung_service.py
from app.repositories.anmeldung_repository import AnmeldungRepository
from app.services.kind_service import KindService
from app.services.wettkampf_service import WettkampfService

class AnmeldungService:
    def __init__(
        self,
        anmeldung_repo: AnmeldungRepository,
        kind_service: KindService,
        wettkampf_service: WettkampfService
    ):
        self.anmeldung_repo = anmeldung_repo
        self.kind_service = kind_service
        self.wettkampf_service = wettkampf_service

    def create_anmeldung(self, data: AnmeldungCreate) -> Anmeldung:
        """
        Business-Logik für Anmeldung:
        1. Kind validieren (startberechtigt?)
        2. Wettkampf prüfen (verfügbar?)
        3. Doppelmeldung ausschließen
        4. Startnummer vergeben
        5. Anmeldung speichern
        """
        # 1. Kind validieren
        kind = self.kind_service.get_kind(data.kind_id)
        if not kind.ist_startberechtigt:
            raise ValidationError("Kind ist nicht startberechtigt")

        # 2. Wettkampf prüfen
        wettkampf = self.wettkampf_service.get_wettkampf(data.wettkampf_id)
        if wettkampf.ist_voll():
            raise WettkampfVollError("Wettkampf ist ausgebucht")

        # 3. Doppelmeldung prüfen
        existing = self.anmeldung_repo.find_by_kind_und_wettkampf(
            data.kind_id, data.wettkampf_id
        )
        if existing:
            raise DoppelmeldungError("Kind bereits angemeldet")

        # 4. Startnummer vergeben
        startnummer = self._vergebe_startnummer(data.wettkampf_id)

        # 5. Anmeldung erstellen
        anmeldung = Anmeldung(
            kind_id=data.kind_id,
            wettkampf_id=data.wettkampf_id,
            startnummer=startnummer,
            status=AnmeldungStatus.BESTAETIGT
        )

        return self.anmeldung_repo.save(anmeldung)

    def _vergebe_startnummer(self, wettkampf_id: int) -> int:
        """Private Hilfsmethode für Startnummernvergabe"""
        max_nummer = self.anmeldung_repo.get_max_startnummer(wettkampf_id)
        return (max_nummer or 0) + 1
----

*Aufgaben:*

* Geschäftsregeln implementieren
* Workflow orchestrieren
* Andere Services aufrufen (Inter-Modul-Kommunikation)
* Fachliche Exceptions werfen
* Transaktionsgrenzen definieren

[WARNING]
====
*Keine Datenbankdetails im Service!*
====

*3. Repository (Data Layer)*

[source,python]
----
# backend/app/repositories/anmeldung_repository.py
from sqlalchemy.orm import Session
from app.models import Anmeldung

class AnmeldungRepository:
    def __init__(self, session: Session):
        self.session = session

    def save(self, anmeldung: Anmeldung) -> Anmeldung:
        """Anmeldung speichern"""
        self.session.add(anmeldung)
        self.session.commit()
        self.session.refresh(anmeldung)
        return anmeldung

    def find_by_id(self, id: int) -> Optional[Anmeldung]:
        """Anmeldung nach ID suchen"""
        return self.session.get(Anmeldung, id)

    def find_by_kind_und_wettkampf(
        self, kind_id: int, wettkampf_id: int
    ) -> Optional[Anmeldung]:
        """Prüfen ob Anmeldung bereits existiert"""
        return self.session.query(Anmeldung).filter(
            Anmeldung.kind_id == kind_id,
            Anmeldung.wettkampf_id == wettkampf_id,
            Anmeldung.status != AnmeldungStatus.STORNIERT
        ).first()

    def get_max_startnummer(self, wettkampf_id: int) -> Optional[int]:
        """Höchste vergebene Startnummer für Wettkampf"""
        result = self.session.query(func.max(Anmeldung.startnummer)).filter(
            Anmeldung.wettkampf_id == wettkampf_id
        ).scalar()
        return result
----

*Aufgaben:*

* CRUD-Operationen
* Datenbank-Queries
* ORM-Mapping
* Performance-Optimierung (Eager Loading, Indizes)

[WARNING]
====
*Keine Business-Logik im Repository!*
====

[NOTE]
====
*Weitere Abschnitte (8.2-8.12) werden schrittweise migriert.*

Die vollständige Dokumentation dieser Konzepte befindet sich aktuell noch in:
`docs/architecture/arc42-aquarius.md`

*Geplante Abschnitte:*

* 8.2 Persistenz und Datenzugriff (inkl. Entity-Relationship-Modell)
* 8.3 Transaktionssteuerung
* 8.4 Fehlerbehandlung
* 8.5 Validierung
* 8.6 Sicherheit
* 8.7 Logging und Monitoring
* 8.8 Offline-Synchronisation
* 8.9 User Experience (UX)
* 8.10 Performance
* 8.11 Testbarkeit
* 8.12 Deployment und Betrieb
====
