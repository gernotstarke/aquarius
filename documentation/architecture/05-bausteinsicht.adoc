== Bausteinsicht

=== Whitebox Gesamtsystem (Level 0)

Das Aquarius-System besteht aus zwei Hauptanwendungen, die auf einem gemeinsamen Backend operieren:

.System Overview
[plantuml, 01-system-overview, svg, opts="inline"]
----
include::images/puml/01-system-overview.puml[]
----

*Begründung:*

* *Zwei Frontend-Anwendungen* für unterschiedliche Nutzungskontexte (Büro vs. Schwimmbad)
* *Ein Backend* für zentrale Business-Logik und Datenkonsistenz
* *Eine Datenbank* mit Cloud-Sync für hybride Online/Offline-Nutzung

=== Bausteinsicht Level 1 - Backend-Module

Das Backend ist in *6 fachliche Module* (Bounded Contexts) strukturiert:

.Backend Modules
[plantuml, 02-backend-modules, svg, opts="inline"]
----
include::images/puml/02-backend-modules.puml[]
----

==== Übersicht der Module

[cols="2,3,3,2", options="header"]
|===
| Modul | Verantwortlichkeit | Zentrale Entitäten | Abhängigkeiten

| *Stammdaten*
| Verwaltung von Basisentitäten
| Verein, Team, Kind, Offizieller
| - (keine)

| *Saisonplanung*
| Planung von Saison und Wettkämpfen
| Saison, Figur, Wettkampf, Schwimmbad
| - (keine)

| *Anmeldung*
| Wettkampfanmeldung und Startnummernvergabe
| Anmeldung
| Stammdaten, Saisonplanung

| *Wettkampf*
| Wettkampfvorbereitung und -struktur
| Station, Gruppe, Durchgang
| Anmeldung, Stammdaten

| *Bewertung*
| Live-Punkteerfassung und Berechnung
| Start, Bewertung
| Wettkampf, Saisonplanung

| *Auswertung*
| Ergebnisse und Ranglisten
| Rangliste, Preis
| Bewertung, Wettkampf
|===


=== Level 2 - Modul "Anmeldung" (Beispiel)

Detaillierte Struktur des Anmeldungs-Moduls:

.Anmeldung Module Structure
[plantuml, 03-anmeldung-module, svg, opts="inline"]
----
include::images/puml/03-anmeldung-module.puml[]
----

==== Schnittstellen des Anmeldungs-Moduls

*Bereitgestellte Schnittstellen (API):*

[cols="3,1,4", options="header"]
|===
| Endpoint | Methode | Beschreibung

| `/api/anmeldungen`
| POST
| Neue Anmeldung erstellen

| `/api/anmeldungen/\{id}`
| GET
| Anmeldung abrufen

| `/api/anmeldungen`
| GET
| Anmeldungen filtern (nach Kind, Wettkampf)

| `/api/anmeldungen/\{id}`
| PUT
| Anmeldung ändern (Figuren)

| `/api/anmeldungen/\{id}`
| DELETE
| Anmeldung stornieren

| `/api/anmeldungen/\{id}/startnummer`
| POST
| Startnummer vergeben
|===

*Benötigte Schnittstellen:*

[cols="2,2,3,3", options="header"]
|===
| Modul | Service | Methode | Zweck

| Stammdaten
| KindService
| `get_kind(id)`
| Kind-Validierung

| Stammdaten
| KindService
| `ist_startberechtigt(id)`
| Berechtigung prüfen

| Saisonplanung
| WettkampfService
| `get_wettkampf(id)`
| Wettkampf-Validierung

| Saisonplanung
| WettkampfService
| `ist_voll(id)`
| Kapazität prüfen

| Saisonplanung
| FigurService
| `validate_figuren(ids, wettkampf_id)`
| Figuren-Validierung
|===

==== Wichtige Algorithmen

*Startnummernvergabe:*

[source,python]
----
def vergebe_startnummer(self, anmeldung_id: int) -> int:
    """
    Vergibt eine eindeutige Startnummer für einen Wettkampf.

    Algorithmus:
    1. Finde höchste vergebene Startnummer für Wettkampf
    2. Nächste freie Nummer = höchste + 1
    3. Optimistic Lock: Bei Konflikt Retry
    """
    anmeldung = self.repo.find_by_id(anmeldung_id)
    wettkampf_id = anmeldung.wettkampf_id

    max_nummer = self.repo.get_max_startnummer(wettkampf_id)
    neue_nummer = (max_nummer or 0) + 1

    anmeldung.startnummer = neue_nummer
    anmeldung.status = AnmeldungStatus.BESTAETIGT

    try:
        self.repo.save(anmeldung)
    except StaleDataError:
        # Retry bei Konflikt
        return self.vergebe_startnummer(anmeldung_id)

    return neue_nummer
----

=== Level 2 - Modul "Bewertung" (Beispiel)

.Bewertung Module Structure
[plantuml, 04-bewertung-module, svg, opts="inline"]
----
include::images/puml/04-bewertung-module.puml[]
----

==== Kernalgorithmus: Endpunkteberechnung

[source,python]
----
def berechne_endpunkte(self, start_id: int) -> Endpunkte:
    """
    Berechnet Endpunkte nach Liga-Regeln:
    1. Höchste und niedrigste Bewertung streichen
    2. Durchschnitt der verbleibenden Bewertungen
    3. Multiplikation mit Schwierigkeitsfaktor

    Beispiel:
    Bewertungen: [7.5, 8.0, 7.0, 8.5, 7.5]
    Gestrichen: 8.5 (höchste), 7.0 (niedrigste)
    Durchschnitt: (7.5 + 8.0 + 7.5) / 3 = 7.67
    Schwierigkeitsfaktor: 2.3
    Endpunkte: 7.67 × 2.3 = 17.64
    """
    bewertungen = self.bewertung_repo.find_by_start(start_id)

    if len(bewertungen) < 3:
        raise ValidationError("Mindestens 3 Bewertungen erforderlich")

    punkte = [b.vorlaeufige_punkte for b in bewertungen]
    punkte_sortiert = sorted(punkte)

    # Höchste und niedrigste streichen
    gestrichene = [punkte_sortiert[0], punkte_sortiert[-1]]
    verbleibende = punkte_sortiert[1:-1]

    # Durchschnitt
    durchschnitt = sum(verbleibende) / len(verbleibende)

    # Schwierigkeitsfaktor holen
    start = self.start_repo.find_by_id(start_id)
    durchgang = self.durchgang_service.get(start.durchgang_id)
    figur = self.figur_service.get(durchgang.figur_id)

    # Endpunkte
    endpunkte_wert = durchschnitt * figur.schwierigkeitsfaktor

    return Endpunkte(
        start_id=start_id,
        endpunkte=round(endpunkte_wert, 2),
        gestrichene_werte=gestrichene,
        durchschnitt=durchschnitt,
        schwierigkeitsfaktor=figur.schwierigkeitsfaktor
    )
----

=== Level 2 - Frontend-Struktur

.Frontend Structure
[plantuml, 05-frontend-structure, svg, opts="inline"]
----
include::images/puml/05-frontend-structure.puml[]
----

==== Frontend-Module

[cols="2,3,3", options="header"]
|===
| Modul | Verantwortlichkeit | Technologie

| *Planungs-App*
| Desktop-optimierte Verwaltungs-UI
| React Router, komplexe Formulare

| *Durchführungs-App*
| Touch-optimierte Wettkampf-UI
| React Router, PWA, große Buttons

| *Shared Components*
| Wiederverwendbare UI-Elemente
| Storybook-dokumentiert

| *API-Client*
| Backend-Kommunikation
| TanStack Query (Caching, Sync)

| *Sync-Service*
| Offline-Fähigkeit
| Service Worker, IndexedDB
|===

=== Modul-Übergreifende Konzepte

==== Inter-Modul-Kommunikation

*Regel:* Module kommunizieren nur über Service-Schnittstellen, niemals direkt über Repositories.

[source,python]
----
# FALSCH: Direkter Repository-Zugriff
class AnmeldungService:
    def __init__(self, db: Session):
        self.kind_repo = KindRepository(db)  # Direkter Zugriff auf fremdes Modul

# RICHTIG: Über Service-Schnittstelle
class AnmeldungService:
    def __init__(
        self,
        anmeldung_repo: AnmeldungRepository,
        kind_service: KindService  # Über Service-Interface
    ):
        self.anmeldung_repo = anmeldung_repo
        self.kind_service = kind_service
----
